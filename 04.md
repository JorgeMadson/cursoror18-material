# Material da aula 04

Temas:
* Continuaçao da aplicação Mytasks:
  * Links
	* Ajax e jquery
* Autenticação com [Devise](https://github.com/plataformatec/devise)

Repositório git com a Aplicação: https://github.com/alexkutzke/mytasks-cursoror18

## Passo a passo

### Ajax e jquery



### Devise

O próximo passo para nossa aplicação é o uso da gem *Devise* para a criação
de um sistema de autenticação de usuários.

Para isso, crie um modelo para usuários:

```bash
rails g model user name:string
rails db:migrate
```

Agora, adicione a gem devise ao seu Gemfile:

```ruby
gem 'devise'
```

Execute bundle install e os demais passos de instalação descritos em
https://github.com/plataformatec/devise#getting-started

```bash
bundle install
rails generate devise:install
```

Para que as informações ao usuário vindas do devise sejam exibidas ao usuário,
adicione o seguinte ao seu view/layouts/application.html.erb

```ruby
	<div>
		<% unless notice.nil? %>
			<div><%= notice %></div>
		<% end %>

		<% unless alert.nil? %>
			<div><%= alert %></div>
		<% end %>
	</div>
```

O próximo passo é atrelar a autenticação ao modelo User:

```bash
rails generate devise User
rails db:migrate
```

Neste momento, é importante reiniciar o servidor da sua aplicação.

Você pode consultar os principais helpers presentes no devise aqui:
https://github.com/plataformatec/devise#controller-filters-and-helpers

Até agora, nós já temos um sistema completo de autenticação (inclusive,
com cadastro de usuários). Basta informarmos quais controladores (e ações)
necessitam que o usuário esteja logado. Por exemplo, desejamos que
os recursos *Welcome*, *Lists* e *Tasks* estejam disponíveis apenas
a usuários logados.

Para isso, adicione em cada um desses controladores o seguinte:

```ruby
before_action :authenticate_user!
```

Agora tente acessar um desses recurso pela sua aplicação. Se você foi levado
a uma tela de solicitação de login, tudo está ok!

Adicione mensagem de boas-vindas e botões de controle no arquivo `app/views/layouts/application.html.rb`:
```erb
	<% if user_signed_in? %>
		Olá <strong><%= current_user.email %></strong>!
	<li><%= link_to "Editar perfil", edit_user_registration_path %></li>
	<li><%= link_to "Sair", destroy_user_session_path, method: :delete %></li>
	<% end %>
```

Agora é necessário que cada usuário veja apenas as suas listas e tarefas. Para isso, precisamos alterar o banco para criar as devidas chaves estrangeiras. Isso é realizado por meio de migrations:

```bash
rails g migration addUserToLists user:references
rails g migration addUserToTasks user:references
rails db:migrate
```

Agora atualize os modelos para que o relacionamento exista no rails (`has_many` e `belongs_to`) e altere os controllers para que o usuário veja, crie e edite suas listas e tarefas.

#### Mais opções

Para personalizar o layout das telas de login e adicionar o campo
de Nome aos formulários. precisamos solicitar ao devise que produza
os arquivos de suas views:

```bash
	$ rails generate devise:views
```

Com isso, sua aplicações possui uma pasta views/devise com várias views.
O primeiro passo é adicionar o campo Name aos formulários de inscrição a atualização
de perfil. Para isso, adicione o seguinte ao seu controllers/application_controller.rb:

```ruby
	before_action :configure_permitted_parameters, if: :devise_controller?

	protected

	def configure_permitted_parameters
		devise_parameter_sanitizer.permit(:sign_up, keys: [:name])
		devise_parameter_sanitizer.permit(:account_update, keys: [:name])
	end
```

Agora o devise aceita o parâmetro name em suas views (e qualquer outro que
você queira adicionar).

É necessário, então, adicionar os devidos campos aos formulários. Primeiro em
views/devise/registrations/edit.html.erb:8

```ruby
	<%= f.input :name, required: true, autofocus: true %>
	<%= f.input :email, required: true %>
```

E, em seguida, no views/devise/registrations/new.html.erb:7

```ruby
	<%= f.input :name, required: true, autofocus: true %>
	<%= f.input :email, required: true %>
```

Pronto, nesse estágio, sua aplicação já possui um sistema de autenticação em
funcionamento. Entretanto, embora o usuário esteja logado, não deveria ser
permitido a todos os usuários acessarem a edição de um filme, por exemplo.
Com isso, precisamos tratar de autorização.

### Cancancan

A gem *cancancan* é responsável por facilitar a criação e manutenção de
regras de autorização em uma aplicação Rails. Para utilizarmos, basta
adicioná-la no Gemfile:

```ruby
	gem 'cancancan'
```

E então, bundle install:

```bash
	$ bundle install
```

Para concluir a instalação, precisamos solicitar a criação do arquivo de
"habilidades":

```bash
	$ rails g cancan:ability
```

O *cancancan* "conversa" muito bem com o *devise* e faz uso do helper _current_user_.
Consulte mais informações sobre o uso do *cancancan* aqui: https://github.com/CanCanCommunity/cancancan#2-check-abilities--authorization

Antes de continuarmos, vamos criar uma nova coluna no modelo User que indicará
se um dado usuário é administrador do sistema, ou não. Para tanto, execute:

```bash
	$ rails g migration AddAdminToUsers admin:boolean
	$ rails db:migrate
```

Para estabelecer quais são as permissões de cada usuário, altere o arquivo
models/ability.rb. Nele, adicione o seguinte:

```ruby
	user ||= User.new # guest user (not logged in)
	if user.admin?
		can :manage, :all
	else
		cannot :manage, :all
	end
```

Com isso, usuários "admin" poderão realizar qualquer operação, enquanto usuários
comuns não terão acesso algum. É claro que esse comportamento não é o desejado,
mas logo iremos corrigir isso.

É necessário, também, indicar em quais controladores (e ações) a autorização
deve ser verificada. Quando utilizamos recursos, basta adicionar o seguinte aos
controladores:

```ruby
	load_and_authorize_resource
```

Com isso, todas as ações do controlador estarão protegidas pelas regras presentes
no arquivo models/ability.rb.

Faça testes e verifique que usuários logados não terão acesso a nenhuma ação
dos controladores projetgidos.

Para melhorar a tela de "acesso negado", altere o arquivo controllers/application_controller.html.erb:

```ruby
	rescue_from CanCan::AccessDenied do |exception|
		respond_to do |format|
			format.json { head :forbidden, content_type: 'text/html' }
			format.html { redirect_to main_app.root_url, alert: exception.message }
			format.js   { head :forbidden, content_type: 'text/html' }
		end
	end
```

Para liberar acesso a usuários comuns, altere o arquivo de habilidades:

```ruby
	user ||= User.new # guest user (not logged in)
	if user.admin?
		can :manage, :all
	else
		cannot :manage, :all
		can :show, :all
		can :search, Movie
	end
```

Utilize o rails console para alterar o stauts de admin de alguns dos usuários
existentes e faça testes de permissão.

Para facilitar a administração de usuários, podemos criar o scaffold para esse
modelo:

```bash
	rails g scaffold_controller user name:string email:string password:string admin:boolean --skip
```

Adicione a rota para recurso Users no config/routes.rb

```ruby
	resources :users
```

Agora, adicione a proteção ao controlador Users e melhore o layout das views geradas.
